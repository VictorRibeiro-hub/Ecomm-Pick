<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Online Picking Productivity Tracker - Integrated Layout</title>
  
  <!-- SheetJS Library for Excel export -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <!-- FontAwesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <!-- Chart.js for dashboards -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- DataLabels Plugin for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

  <style>
    /* Global Reset and Body Styling */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background-color: #f5f5f5; color: #333; }

    /* Top Bar */
    .top-bar {
      background-color: #d32f2f; /* Alterado para vermelho */
      color: #fff;
      padding: 15px 20px;
      font-size: 26px;
      font-weight: bold;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .top-bar .logo-container img { height: 50px; }
    .top-bar > span { flex-grow: 1; }
    /* --- NAV DOS TABS (espaçamento uniforme) --- */
.tab-nav {
  display: flex;
  align-items: center;
  /* distancia igual entre botões */
  column-gap: 8px;        /* ajuste fino do espaçamento entre botões */
}

/* --- BOTÃO DE TAB (tamanho e alinhamento consistentes) --- */
.tab-btn {
  background: transparent;
  border: none;
  color: #fff;
  position: relative;
  cursor: pointer;
  /* padding um pouco maior para “respirar” */
  padding: 8px 12px;
  /* garante alinhamento do ícone + texto */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;                 /* espaço entre ícone e texto */
  /* todos com a MESMA “largura base” */
  min-width: 112px;         /* pode ajustar p/ 100–130px conforme gosto */
  transition: color 0.3s, background 0.3s;
}

/* --- TEXTO NO HOVER (sem empurrar layout) --- */
.tab-btn .btn-text {
  font-size: 14px;
  color: yellow;
  opacity: 0;
  max-width: 0;             /* não ocupa largura quando escondido */
  overflow: hidden;         /* evita empurrar o layout */
  transition: max-width 0.25s ease, opacity 0.25s ease;
}

.tab-btn:hover .btn-text {
  opacity: 1;
  max-width: 80px;          /* largura suficiente p/ “Home”, “Gaps”, etc. */
}

/* opcional: leve “realce” no hover (coerente com seu ativo) */
.tab-btn:hover {
  background: rgba(255,255,255,0.12);
  border-radius: 8px;
}

    .user-info {
      font-weight: normal;
      font-size: 12px;
      opacity: 0.8;
    }

    /* Container with Sidebar and Main Content */
    .container {
      display: flex;
      position: absolute;
      top: 70px;
      bottom: 0;
      left: 0;
      right: 0;
    }

    /* Sidebar Styling */
    .sidebar {
      width: 240px;
      background-color: #000;
      padding: 30px 20px 20px 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-shadow: 3px 0 8px rgba(0, 0, 0, 0.3);
    }
    .sidebar .file-label, .sidebar button {
      text-decoration: none;
      font-size: 16px;
      padding: 8px;
      border: none;
      background: transparent;
      color: #fff;
      text-align: left;
      cursor: pointer;
      transition: background 0.3s, padding-left 0.3s;
    }
    .sidebar .file-label:hover, .sidebar button:hover {
      background: rgba(255, 255, 255, 0.2);
      padding-left: 20px;
    }
    /* Esconder o input de arquivo */
    #csvFileInput { display: none; }

    /* Summary Cards */
    .summary-card {
      background-color: #1a1a1a;
      color: #fff;
      padding: 10px;
      border-radius: 6px;
      text-align: center;
      font-size: 14px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      margin-top: 8px;
    }
    .summary-card.dual {
      display: flex;
      justify-content: space-between;
      padding: 6px 8px;
    }
    .summary-card.dual .summary-item {
      flex: 1; display: flex; flex-direction: column; align-items: center;
    }
    .summary-card.dual .summary-item:first-child {
      border-right: 1px solid rgba(255,255,255,0.3);
    }
    .summary-number { font-size: 20px; font-weight: bold; margin-top: 4px; color: #ffc107; }
/* --- Toggle do Summary (usar filtros da Home) --- */
.aff-toggle {
  display:flex;
  align-items:center;
  gap:8px;
  margin-left: auto;               /* empurra toggle para o centro entre título e legenda */
  margin-right: 8px;
}

.aff-toggle-label {
  font-size: 12px;
  color: #333;
  background: #f5f5f5;
  border: 1px solid #eee;
  padding: 3px 8px;
  border-radius: 999px;
}

/* Switch minimalista */
.switch {
  position: relative;
  display: inline-block;
  width: 42px;
  height: 22px;
}
.switch input { display:none; }

.slider {
  position: absolute; cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc; transition: .2s; border-radius: 22px;
}
.slider:before {
  position: absolute; content: "";
  height: 18px; width: 18px; left: 2px; top: 2px;
  background-color: white; transition: .2s; border-radius: 50%;
}
.switch input:checked + .slider { background-color: #d32f2f; }
.switch input:checked + .slider:before { transform: translateX(20px); }


    /* Main Content Styling */
    .main-content {
      margin-top: -5px;
      margin-left: 1px;
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .content-area { 
  padding: 20px 20px 60px;  /* top | right | bottom (maior) | left */
  flex: 1;
  overflow-y: auto;
  background-color: #fff;
}


    /* Tabelas */
    table {
      width: 100%; border-collapse: collapse; margin-top: 5px; background-color: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    th, td {
      padding: 5px; text-align: center; border: 1px solid #ddd; word-wrap: break-word; line-height: 1.3;
    }
    #productivityTable th:nth-child(8) { width: 180px; }
    #productivityTable td:nth-child(8) {
      max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    #productivityTable tbody td, #gapsTable tbody td { font-size: 14px; }

    th {
      background-color: #000; color: white; position: sticky; top: 0; z-index: 2;
    }
    #productivityTable thead tr:first-child th,
    #gapsTable thead tr:first-child th { font-size: 14px; }

    tbody tr:hover { background-color: #f1f1f1; }

    .filter-row input, .filter-row select {
      width: 90%; padding: 5px; font-size: 12px; border: 1px solid #ccc; border-radius: 3px;
    }

    .content-area::-webkit-scrollbar { width: 8px; }
    .content-area::-webkit-scrollbar-thumb { background-color: #d32f2f; border-radius: 5px; }
    .content-area::-webkit-scrollbar-thumb:hover { background-color: #a72727; }

    .performance-well-done { color: #28a745; font-weight: bold; }
    .performance-poor { color: #dc3545; font-weight: bold; }
    .performance-almost-there { color: #ff8c00; font-weight: bold; }
    .performance-no-activity { color: #000; font-weight: bold; }

    #productivityTable thead tr:first-child th {
      position: sticky; top: 0; background-color: #000; z-index: 3;
    }
    #productivityTable thead tr.filter-row th {
      position: sticky; top: 40px; background-color: #000; z-index: 2;
    }

    /* Gaps – preserva as cores base */
tr.gap-same-floor td { background-color: #d4edda !important; }
tr.gap-cross-floor td { background-color: #f8d7da !important; }

/* Virada de List ID – sem contorno */
tr.list-change td { border: none; }

/* Sem faixinha à esquerda */
tr.list-change td:first-child { border: none; }

/* Location IN/OUT em negrito + asteriscos laterais */
td.list-change-cell {
  font-weight: bold;
  background: transparent !important;
  border: none !important;
  position: relative; /* habilita posicionamento dos pseudo-elementos */
}

td.list-change-cell::before,
td.list-change-cell::after {
  content: "*";
  font-weight: bold;
  /* opcional: ajuste fino de espaçamento */
  margin: 0 4px;
}

td.list-change-cell::before { margin-right: 6px; }
td.list-change-cell::after  { margin-left: 6px; }

/* Empilhar input + select no filtro de User ID */
.stack { display: flex; flex-direction: column; gap: 4px; }

/* ===== Summary (AGY × CORE) – visual refresh ===== */
.aff-wrap { padding: 6px 10px 14px; }
.aff-header {
  display:flex; align-items:center; justify-content:space-between;
  gap:12px; margin-bottom:10px;
}
.aff-title { font-weight:700; font-size:18px; display:flex; gap:10px; align-items:center; }
.aff-title i { font-size:18px; color:#d32f2f; }
.aff-legend { display:flex; gap:8px; flex-wrap:wrap; opacity:.85; }
.badge {
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; border-radius:999px; font-size:12px; font-weight:600;
  background:#f5f5f5; color:#333; border:1px solid #eee;
}
.badge .dot { width:8px; height:8px; border-radius:50%; display:inline-block; }
.dot-core { background:#28a745; }
.dot-agy  { background:#ff8c00; }

.aff-grid {
  display:grid; gap:14px;
  grid-template-columns: 1fr 1fr;
}
@media (max-width: 1100px){
  .aff-grid { grid-template-columns: 1fr; }
}

.kpi-card { padding:12px; border-radius:10px; background:#111; color:#fff; box-shadow:0 4px 10px rgba(0,0,0,.15); }
.kpi-head { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
.kpi-head .label { font-weight:700; letter-spacing:.3px; display:flex; gap:8px; align-items:center; }
.kpi-head .label i { opacity:.9; }
.kpi-grid {
  display:grid; gap:10px;
  grid-template-columns: repeat(4, 1fr);
}
.kpi-item { text-align:center; background:#1a1a1a; border-radius:8px; padding:10px 8px; }
.kpi-item .k { font-size:12px; opacity:.8; }
.kpi-item .v { font-size:20px; font-weight:800; color:#ffc107; margin-top:2px; }
/* Ocupa a linha inteira e centraliza o conteúdo */
.kpi-item.wide {
  grid-column: 1 / -1;         /* pega todas as 4 colunas */
  justify-self: center;         /* centraliza o bloco no grid */
  text-align: center;           /* centraliza o texto */
}

/* opcional: dá um “peso visual” maior pro valor */
.kpi-item.wide .v {
  font-size: 22px;
}
.bucket-card { padding:10px; border-radius:10px; background:#111; color:#fff; box-shadow:0 4px 10px rgba(0,0,0,.15); }
.bucket-title { font-weight:700; margin-bottom:8px; display:flex; gap:8px; align-items:center; }
.bucket-grid { display:grid; gap:10px; grid-template-columns: repeat(4, 1fr); }
.bucket-pill { text-align:center; background:#1a1a1a; border-radius:8px; padding:10px 8px; }
.bucket-pill .k { font-size:12px; opacity:.8; }
.bucket-pill .v { font-size:18px; font-weight:800; margin-top:2px; }
.bucket-wd  .v { color:#28a745; }
.bucket-at  .v { color:#ff8c00; }
.bucket-poor .v { color:#dc3545; }
.bucket-na  .v { color:#6c757d; }

.chart-row {
  display:grid; gap:14px; margin-top:6px;
  grid-template-columns: 1fr 1fr;
}
@media (max-width:1100px){
  .chart-row { grid-template-columns: 1fr; }
}
.chart-card { background:#fff; border-radius:10px; padding:10px; box-shadow:0 4px 10px rgba(0,0,0,.1); }
.chart-card h4 { margin:6px 0 10px; font-size:14px; letter-spacing:.2px; }
canvas#affAvgPerfChart, canvas#affBucketChart { width:100% !important; height:360px !important; }
/* Summary: animação suave ao abrir a aba */
#affiliationTabContent {
  opacity: 0;
  transform: translateY(6px);
  transition: opacity .25s ease, transform .25s ease;
}

#affiliationTabContent.is-visible {
  opacity: 1;
  transform: translateY(0);
}
/* Dashboard: reduzir o pie */
#performancePieChart{
  max-width: 500px;
  max-height: 500px;
}
/* Aba ativa: leve destaque/realce no ícone */
.tab-btn.active {
  background: rgba(255,255,255,0.18);
  border-radius: 8px;
  box-shadow: 0 0 0 2px rgba(255,255,255,0.25) inset;
}
.tab-btn.active i {
  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));
}
.tab-btn:focus-visible .btn-text { opacity:1; max-width:80px; }
.tab-btn:focus-visible { outline: 2px solid rgba(255,255,255,0.35); border-radius:8px; }


  </style>
</head>
<body>
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="logo-container">
      <img src="dhl-logo.png" alt="DHL Logo" />
    </div>
    <span>Online Picking Productivity Tracker</span>

    <div class="tab-nav">
      <button class="tab-btn" id="homeTabBtn" data-target="homeTabContent" title="Home">
  <i class="fa fa-home"></i><span class="btn-text">Home</span>
</button>
<button class="tab-btn" id="gapsTabBtn" data-target="gapsTabContent" title="Gaps">
  <i class="fa fa-chart-bar"></i><span class="btn-text">Gaps</span>
</button>
<button class="tab-btn" id="dashboardTabBtn" data-target="dashboardTabContent" title="Dashboard">
  <i class="fa fa-chart-pie"></i><span class="btn-text">Dashboard</span>
</button>
<button class="tab-btn" id="affTabBtn" data-target="affiliationTabContent" title="Summary AGY × CORE">
  <i class="fa fa-users"></i><span class="btn-text">Summary</span>
</button>

    </div>

    <div class="user-info">Victor Ribeiro (DHL Supply Chain)</div>
  </div>

  <!-- Container -->
  <div class="container">
    <!-- Sidebar -->
    <nav class="sidebar">
      <label for="csvFileInput" id="fileLabel" class="file-label">
        <i class="fa fa-file"></i> Choose CSV File
      </label>
      <!-- aceita csv e tsv -->
      <input type="file" id="csvFileInput" accept=".csv,.tsv,text/csv,text/tab-separated-values" />

      <button id="downloadReportBtnXLSX">
        <i class="fa fa-download"></i> Download XLSX
      </button>
      
      <div class="summary-card">
        Total User IDs
        <div class="summary-number" id="userCountLabel">0</div>
      </div>
      <div class="summary-card">
        User-equivalents Lost (≈)
        <div class="summary-number" id="userLostLabel">0.00</div>
      </div>
      <div class="summary-card">
        T.W.H
        <div class="summary-number" id="twhLabel">00:00:00</div>
      </div>
      <div class="summary-card">
        Prod. Hours
        <div class="summary-number" id="prodHoursLabel">00:00:00</div>
      </div>
      <div class="summary-card">
        Total Gaps
        <div class="summary-number" id="differenceLabel">00:00:00</div>
      </div>

      <div class="summary-card dual">
        <div class="summary-item">
          Total Picked
          <div class="summary-number" id="totalPickedLabel">0</div>
        </div>
        <div class="summary-item">
          Avg. Picked
          <div class="summary-number" id="avgPickedLabel">0.00</div>
        </div>
      </div>

      <div class="summary-card">
  Avg. Performance
  <div class="summary-number" id="avgPerformanceLabel">0.00%</div>
</div>

<!-- NOVO: mediana da performance -->
<div class="summary-card">
  Performance — Median
  <div class="summary-number" id="medianPerformanceLabel">0.00%</div>
</div>


    </nav>

    <!-- Main Content -->
    <div class="main-content">
      <div class="content-area">
        <!-- Home -->
                       <div id="homeTabContent" class="allow-copy">
          <table id="productivityTable">
            <thead>
              <tr>
                <th style="width: 100px;">Date</th>
                <th>User ID</th>
                <th>Qty</th>
                <th>In Time</th>
                <th>Out Time</th>
                <th>Total Hours</th>
                <th>Prod. Hours</th>
                <th>Performance</th>
                <th>Total Gaps</th>
                <th>N. Gaps</th>
                <th>Qty. Tnx</th>
                <th>Gap vs Txn%</th>
                <th style="width: 15mm;">Avg. P. Hours</th>
                <th>Pick</th>
              </tr>
              <tr class="filter-row">
                <th></th>
                <th>
  <div class="stack">
    <input type="text" id="filterUserId" placeholder="Filter by User ID" />
    <select id="filterAffiliation" title="Filter by Affiliation">
      <option value="">All</option>
      <option value="CORE">CORE</option>
      <option value="AGY">AGY</option>
    </select>
  </div>
</th>

                <th></th><th></th><th></th><th></th><th></th>
                <th>
                  <select id="filterPerformance">
                    <option value="">All</option>
                    <option value="Well Done">Well Done</option>
                    <option value="Almost There">Almost There</option>
                    <option value="Poor">Poor</option>
                    <option value="No Activity">No Activity</option>
                  </select>
                </th>
                <th></th><th></th><th></th><th></th><th></th>
                <th>
                  <select id="filterPick">
                    <option value="">All</option>
                    <option value="Single">Single</option>
                    <option value="Multi">Multi</option>
                  </select>
                </th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <!-- Gaps -->
        <div id="gapsTabContent" class="allow-copy" style="display:none;">
          <table id="gapsTable">
            <thead>
              <tr>
                <th style="width: 100px;">Date</th>
                <th>User ID</th>
                <th>Location IN</th>
                <th>Location OUT</th>
                <th>In Time</th>
                <th>Out Time</th>
                <th>Gap Time</th>
                <th>Gap #</th>
                <th>Same Floor?</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <!-- Dashboard -->
        <div id="dashboardTabContent" class="allow-copy" style="display:none;">
          <div class="dashboard-cards" style="display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 0px;">
            <div class="summary-card">Total Users <div class="summary-number" id="dashboardUserCount">0</div></div>
            <div class="summary-card">Total Picks <div class="summary-number" id="dashboardTotalPicks">0</div></div>
            <div class="summary-card">Avg. Picks/Hora <div class="summary-number" id="dashboardAvgPicksPerHour">0.00</div></div>
            <div class="summary-card">Avg. Performance <div class="summary-number" id="dashboardAvgPerformance">0.00%</div></div>
            <div class="summary-card">Total Gaps <div class="summary-number" id="dashboardTotalGaps">00:00:00</div></div>
          </div>

          <div class="dashboard-charts" style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;">
            <div style="flex: 1; min-width: 300px; margin-left: 100px;">
              <canvas id="performancePieChart"></canvas>

            </div>
            <div style="flex: 1; min-width: 300px; margin-top: 0px;">
              <div class="dashboard-bar-labels" style="display: flex; justify-content: center; gap: 12px; margin-bottom: 8px;">
                <div class="summary-card" style="margin-top: 0; padding: 6px 12px;">Well Done:&nbsp;<span class="summary-number" id="countWellDone">0</span></div>
                <div class="summary-card" style="margin-top: 0; padding: 6px 12px;">Almost There:&nbsp;<span class="summary-number" id="countAlmostThere">0</span></div>
                <div class="summary-card" style="margin-top: 0; padding: 6px 12px;">Poor:&nbsp;<span class="summary-number" id="countPoor">0</span></div>
                <div class="summary-card" style="margin-top: 0; padding: 6px 12px;">No Activity:&nbsp;<span class="summary-number" id="countNoActivity">0</span></div>
              </div>
              <canvas id="performanceBarChart"></canvas>
            </div>
          </div>

          <div class="dashboard-tables" style="display: flex; gap: 20px; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 200px;">
              <h4>Top 5 Performance Scores</h4>
              <table id="topPerformersTable" class="dashboard-table">
                <thead><tr><th>User ID</th><th>Performance</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
            <div style="flex: 1; min-width: 200px;">
              <h4>Bottom 5 Performance Scores</h4>
              <table id="topLowTable" class="dashboard-table">
                <thead><tr><th>User ID</th><th>Performance</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
            <div style="flex: 1; min-width: 200px;">
              <h4>Top 5 Time Gaps</h4>
              <table id="topGapsTable" class="dashboard-table">
                <thead><tr><th>User ID</th><th>Total Gap Time</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
<!-- Affiliation Summary (AGY × CORE) -->
<div id="affiliationTabContent" class="allow-copy" style="display:none;">
  <div class="aff-wrap">
    <div class="aff-header">
  <div class="aff-title">
    <i class="fa fa-users"></i>
    <span>Affiliation Summary</span>
  </div>

  <!-- NOVO: Toggle “usar filtros da Home” -->
  <div class="aff-toggle" title="Aplicar os filtros ativos da aba Home ao Summary">
    <label class="switch">
      <input type="checkbox" id="affUseFilterToggle">
      <span class="slider"></span>
    </label>
    <span class="aff-toggle-label">Usar filtros da Home</span>
  </div>

  <div class="aff-legend">
    <span class="badge"><span class="dot dot-core"></span> CORE</span>
    <span class="badge"><span class="dot dot-agy"></span> AGY</span>
  </div>
</div>


    <!-- KPIs lado a lado -->
    <div class="aff-grid">
      <!-- CORE -->
      <div class="kpi-card">
        <div class="kpi-head">
          <div class="label"><i class="fa fa-id-card"></i> CORE — KPIs</div>
        </div>
        <div class="kpi-grid">
          <div class="kpi-item">
            <div class="k">Users</div>
            <div class="v" id="kpiCoreUsers">0</div>
          </div>
          <div class="kpi-item">
            <div class="k">Avg Perf</div>
            <div class="v" id="kpiCoreAvgPerf">0.00%</div>
          </div>
          <div class="kpi-item">
            <div class="k">Med Perf</div>
            <div class="v" id="kpiCoreMedPerf">0.00%</div>
          </div>
          <div class="kpi-item">
            <div class="k">Avg Picks/h</div>
            <div class="v" id="kpiCoreAvgPicksHr">0.00</div>
          </div>
          <div class="kpi-item wide">
            <div class="k">Total Gaps</div>
            <div class="v" id="kpiCoreGaps">00:00:00</div>
          </div>
        </div>
      </div>

      <!-- AGY -->
      <div class="kpi-card">
        <div class="kpi-head">
          <div class="label"><i class="fa fa-briefcase"></i> AGY — KPIs</div>
        </div>
        <div class="kpi-grid">
          <div class="kpi-item">
            <div class="k">Users</div>
            <div class="v" id="kpiAgyUsers">0</div>
          </div>
          <div class="kpi-item">
            <div class="k">Avg Perf</div>
            <div class="v" id="kpiAgyAvgPerf">0.00%</div>
          </div>
          <div class="kpi-item">
            <div class="k">Med Perf</div>
            <div class="v" id="kpiAgyMedPerf">0.00%</div>
          </div>
          <div class="kpi-item">
            <div class="k">Avg Picks/h</div>
            <div class="v" id="kpiAgyAvgPicksHr">0.00</div>
          </div>
          <div class="kpi-item wide">
            <div class="k">Total Gaps</div>
            <div class="v" id="kpiAgyGaps">00:00:00</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Buckets lado a lado -->
    <div class="aff-grid" style="margin-top:8px;">
      <div class="bucket-card">
        <div class="bucket-title"><i class="fa fa-layer-group"></i> Performance Buckets — CORE</div>
        <div class="bucket-grid">
          <div class="bucket-pill bucket-wd">
            <div class="k">Well Done</div>
            <div class="v" id="coreCountWD">0</div>
          </div>
          <div class="bucket-pill bucket-at">
            <div class="k">Almost</div>
            <div class="v" id="coreCountAT">0</div>
          </div>
          <div class="bucket-pill bucket-poor">
            <div class="k">Poor</div>
            <div class="v" id="coreCountPoor">0</div>
          </div>
          <div class="bucket-pill bucket-na">
            <div class="k">No Act.</div>
            <div class="v" id="coreCountNA">0</div>
          </div>
        </div>
      </div>

      <div class="bucket-card">
        <div class="bucket-title"><i class="fa fa-layer-group"></i> Performance Buckets — AGY</div>
        <div class="bucket-grid">
          <div class="bucket-pill bucket-wd">
            <div class="k">Well Done</div>
            <div class="v" id="agyCountWD">0</div>
          </div>
          <div class="bucket-pill bucket-at">
            <div class="k">Almost</div>
            <div class="v" id="agyCountAT">0</div>
          </div>
          <div class="bucket-pill bucket-poor">
            <div class="k">Poor</div>
            <div class="v" id="agyCountPoor">0</div>
          </div>
          <div class="bucket-pill bucket-na">
            <div class="k">No Act.</div>
            <div class="v" id="agyCountNA">0</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Gráficos lado a lado, maiores -->
    <div class="chart-row">
      <div class="chart-card">
        <h4>Median Performance — AGY × CORE</h4>

        <canvas id="affAvgPerfChart"></canvas>
      </div>
      <div class="chart-card">
        <h4>Performance Buckets por Affiliation</h4>
        <canvas id="affBucketChart"></canvas>
      </div>
    </div>
  </div>
</div>

      </div> <!-- content-area -->
    </div> <!-- main-content -->
  </div> <!-- container -->

  <!-- JavaScript -->
  <script>
    /* ======================================================
     * Configurações Globais
     * ====================================================== */
    const trackerTarget = 62; // Target fixo de 62 unidades/hora
// Summary: alterna FULL vs filtros da Home
let affUseFiltered = false;

// Decide a fonte do Summary conforme o toggle.
// 1) OFF  -> usa FULL (localStorage)
// 2) ON   -> tenta sessionStorage; se não houver, aplica filtros atuais do UI na hora
function getSummarySourceMap() {
  const fullSaved = localStorage.getItem('onlinePickData');
  if (!fullSaved) return null;

  if (!affUseFiltered) return JSON.parse(fullSaved);

  // Verifica se o cache filtrado pertence ao mesmo dataset (timestamp)
  const fullTs = localStorage.getItem('onlinePickData_ts') || '';
  const cached = sessionStorage.getItem('onlinePickDataFiltered');
  const cachedTs = sessionStorage.getItem('onlinePickDataFiltered_ts') || '';

  if (cached && cachedTs === fullTs) {
    try {
      const parsed = JSON.parse(cached);
      if (parsed && Object.keys(parsed).length) return parsed;
    } catch(e){}
  }

  // Recalcula com os filtros atuais da Home e atualiza cache + ts
  try {
    const full = JSON.parse(fullSaved);
    const filteredNow = getFilteredMapFromUI(full);
    sessionStorage.setItem('onlinePickDataFiltered', JSON.stringify(filteredNow));
    sessionStorage.setItem('onlinePickDataFiltered_ts', fullTs);
    return filteredNow;
  } catch(e){
    return JSON.parse(fullSaved);
  }
}



    /* ======================================================
     * Funções Utilitárias
     * ====================================================== */
    // Normaliza "9:05 PM", "09:05", "09:05:07 am" -> "21:05:00" (sempre HH:MM:SS 24h)
function normalizeTime(str) {
  if (!str) return '00:00:00';
  let t = String(str).trim().toUpperCase().replace(/"/g,'').replace(/'/g,'');
  const m = t.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)?$/);
  if (!m) {
    // fallback: "HH" ou "HH:MM"
    const m2 = t.match(/^(\d{1,2})(?::(\d{2}))?$/);
    if (m2) {
      const hh = String(parseInt(m2[1] || '0',10)).padStart(2,'0');
      const mm = String(parseInt(m2[2] || '0',10)).padStart(2,'0');
      return `${hh}:${mm}:00`;
    }
    return '00:00:00';
  }
  let hh = parseInt(m[1] || '0',10);
  const mm = parseInt(m[2] || '0',10);
  const ss = parseInt(m[3] || '0',10);
  const ampm = m[4];

  if (ampm === 'AM' && hh === 12) hh = 0;
  if (ampm === 'PM' && hh < 12) hh += 12;

  return (
    String(hh).padStart(2,'0') + ':' +
    String(mm).padStart(2,'0') + ':' +
    String(ss).padStart(2,'0')
  );
}

function timeToSeconds(time) {
  const [h, m, s] = normalizeTime(time).split(':').map(Number);
  return (h || 0) * 3600 + (m || 0) * 60 + (s || 0);
}
function ensureTimeFormat(time) {
  // garante HH:MM:SS 24h em todas as entradas
  return normalizeTime(time);
}

    function calculateSecondsDifference(start, end) {
      start = ensureTimeFormat(start.trim());
      end = ensureTimeFormat(end.trim());
      const startSec = timeToSeconds(start);
      const endSec = timeToSeconds(end);
      let diff = endSec - startSec;
      if (diff < 0) diff += 24 * 3600;
      return diff;
    }
    function formatDecimalToTime(decimalHours) {
      let sign = "";
      if (decimalHours < 0) { sign = "-"; decimalHours = Math.abs(decimalHours); }
      const totalSeconds = Math.round(decimalHours * 3600);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 3600 % 60;
      return sign + String(hours).padStart(2, '0') + ":" + String(minutes).padStart(2, '0') + ":" + String(seconds).padStart(2, '0');
    }
    // Agora não reformatamos a data — vem pronta do CSV novo
    function formatDate(date){ return date || ''; }

    // Mapear prefixo de location para floor
    function getFloor(location) {
      if (!location) return null;
      const loc = location.toUpperCase().trim();
      if (loc.startsWith('DROP'))   return 'ground';
      if (loc.startsWith('CONSOL')) return 'ground';
      const letter = loc.charAt(0);
      const floorMap = {
        X: 'ground', Z: 'ground', A: 'ground', E: 'ground', P: 'ground', F: 'ground',
        B: 'bFloor', V: 'bFloor',
        D: 'dFloor', C: 'dFloor',
        T: 'tFloor', H: 'tFloor'
      };
      return floorMap[letter] || 'unknown';
    }
function getAffiliationFromUserId(userId) {
  const u = String(userId || '').trim().toUpperCase();
  // Robustez: aceita "AGY", "AGY-", "AGY_", "AGY John", "AGYJohn", etc.
  return u.startsWith('AGY') ? 'AGY' : 'CORE';
}
/* ======================================================
 * Render helpers (rebuild único e leve)
 * ====================================================== */
function renderTablesOnly(map){
  updateTable(map);
  updateStats(map);
  updateGapsTable(map);
  updateDashboard(map);
}

function renderChartsOnly(map){
  renderDashboardCharts(map);
  renderDashboardTables(map);
  updateAffiliationSummary(map);
}

function rebuildUI(map, { deferCharts = true } = {}){
  // 1) Render leve primeiro (tabelas, cards)
  renderTablesOnly(map);

  // 2) Gráficos depois (evita “congelar” ao carregar ficheiros grandes)
  if (deferCharts){
    requestAnimationFrame(() => renderChartsOnly(map));
  } else {
    renderChartsOnly(map);
  }
}

    /* ======================================================
     * Troca de Abas
     * ====================================================== */
    function hideAllTabs() {
  document.getElementById('homeTabContent').style.display = 'none';
  document.getElementById('gapsTabContent').style.display = 'none';
  document.getElementById('dashboardTabContent').style.display = 'none';
  document.getElementById('affiliationTabContent').style.display = 'none';
}

function setActiveTab(btnId){
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById(btnId);
  if (btn) btn.classList.add('active');
}

function showHomeTab() {
  hideAllTabs();
  document.getElementById('homeTabContent').style.display = 'block';
  setActiveTab('homeTabBtn');
}

function showGapsTab() {
  hideAllTabs();
  document.getElementById('gapsTabContent').style.display = 'block';
  setActiveTab('gapsTabBtn');
}

function showDashboardTab() {
  hideAllTabs();
  const tab = document.getElementById('dashboardTabContent');
  tab.style.display = 'block';
  setActiveTab('dashboardTabBtn');

  const saved = localStorage.getItem('onlinePickData');
  if (saved) {
    const fullMap = JSON.parse(saved);

    const fullTs   = localStorage.getItem('onlinePickData_ts') || '';
    const cached   = sessionStorage.getItem('onlinePickDataFiltered');
    const cachedTs = sessionStorage.getItem('onlinePickDataFiltered_ts') || '';

    let dataMap;
    if (cached && cachedTs === fullTs) {
      dataMap = JSON.parse(cached);
    } else {
      dataMap = getFilteredMapFromUI(fullMap);
      sessionStorage.setItem('onlinePickDataFiltered', JSON.stringify(dataMap));
      sessionStorage.setItem('onlinePickDataFiltered_ts', fullTs);
    }

    updateDashboard(dataMap);
    renderDashboardCharts(dataMap);
    renderDashboardTables(dataMap);
  }

  // garante redimensionamento dos gráficos
  requestAnimationFrame(() => {
    if (window.performancePie && typeof window.performancePie.resize === 'function') {
      window.performancePie.resize();
    }
    if (window.performanceBar && typeof window.performanceBar.resize === 'function') {
      window.performanceBar.resize();
    }
  });
}

function showAffiliationTab() {
  hideAllTabs();
  const tab = document.getElementById('affiliationTabContent');
  tab.style.display = 'block';
  setActiveTab('affTabBtn');
  tab.classList.remove('is-visible');

  requestAnimationFrame(() => {
    const src = getSummarySourceMap();
    if (src) updateAffiliationSummary(src);

    // Força reflow e aplica a classe de reveal
    tab.getBoundingClientRect();
    tab.classList.add('is-visible');

    if (window.affAvgPerfChart && typeof window.affAvgPerfChart.resize === 'function') {
      window.affAvgPerfChart.resize();
    }
    if (window.affBucketChart && typeof window.affBucketChart.resize === 'function') {
      window.affBucketChart.resize();
    }
  });
}

    /* ======================================================
     * Home Table
     * ====================================================== */
    function updateTable(dataMap) {
  const tableBody = document.querySelector('#productivityTable tbody');
  let html = '';
  for (const [userId, s] of Object.entries(dataMap)) {
    const prodHours = formatDecimalToTime(s.qty / trackerTarget);
    const gapTxnPercent = s.txnCount ? ((s.nGaps / s.txnCount) * 100).toFixed(2) + "%" : "0.00%";
    const totalHoursDecimal = timeToSeconds(s.totalHours) / 3600;
    const avgPHours = totalHoursDecimal > 0 ? (s.qty / totalHoursDecimal).toFixed(0) : "0";
    const pick = s.hasMulti ? 'Multi' : 'Single';
    html += `
      <tr>
        <td>${s.date || ''}</td>
        <td>${userId}</td>
        <td>${s.qty}</td>
        <td>${s.inTime || 'N/A'}</td>
        <td>${s.outTime || 'N/A'}</td>
        <td>${s.totalHours || '00:00:00'}</td>
        <td>${prodHours}</td>
        <td class="${s.performanceClass}">${s.performance}</td>
        <td>${formatDecimalToTime(s.totalGaps)}</td>
        <td>${s.nGaps || 0}</td>
        <td>${s.txnCount || 0}</td>
        <td>${gapTxnPercent}</td>
        <td>${avgPHours}</td>
        <td style="${pick === 'Multi' ? 'background-color:#ffcccc;' : ''}">${pick}</td>
      </tr>`;
  }
  tableBody.innerHTML = html;
} // <= ESTA CHAVE FALTAVA



    /* ======================================================
     * Gaps Table
     * ====================================================== */
    // SUBSTITUI a função inteira updateGapsTable por esta versão
function updateGapsTable(dataMap) {
  const gapsTableBody = document.querySelector('#gapsTable tbody');
  gapsTableBody.innerHTML = '';

  Object.entries(dataMap).forEach(([userId, stats]) => {
    const hasGaps = stats.nGaps > 0 && Array.isArray(stats.gapsList) && stats.gapsList.length > 0;

    if (hasGaps) {
      stats.gapsList.forEach((gapObj, index) => {
        const gapTimeFormatted = formatDecimalToTime(gapObj.gapSec / 3600);
        const gapMinutes = gapObj.gapSec / 60;

        const row = document.createElement('tr');
        row.classList.add(gapObj.sameFloor ? 'gap-same-floor' : 'gap-cross-floor');

        row.innerHTML = `
          <td>${stats.date || ''}</td>
          <td>${userId}</td>
          <td>${gapObj.locationIn || ''}</td>
          <td>${gapObj.locationOut || ''}</td>
          <td>${gapObj.start || 'N/A'}</td>
          <td>${gapObj.end || 'N/A'}</td>
          <td>${gapTimeFormatted}</td>
          <td>${index + 1}</td>
          <td>${gapObj.sameFloor ? 'Yes' : 'No'}</td>
        `;

        // Destacar só Location IN/OUT quando houver virada de List ID
        if (gapObj.listChange) {
          const tds = row.querySelectorAll('td');
          [2, 3].forEach(i => {
            tds[i].classList.add('list-change-cell');
            tds[i].title = `List ID: ${gapObj.fromList || ''} → ${gapObj.toList || ''}`;
          });
        }

        // Destacar gaps acima do limiar
        const gapCell = row.querySelectorAll('td')[6];
        if (gapObj.sameFloor) {
          if (gapMinutes >= 7) { gapCell.style.color = '#dc3545'; gapCell.style.fontWeight = 'bold'; }
        } else {
          if (gapMinutes >= 12) { gapCell.style.color = '#dc3545'; gapCell.style.fontWeight = 'bold'; }
        }

        gapsTableBody.appendChild(row);
      });
    } else {
      // --- Linha “sem gaps” para espelhar a Home ---
      const row = document.createElement('tr');
      // sem classes de cor (nem same/cross-floor)
      row.innerHTML = `
        <td>${stats.date || ''}</td>
        <td>${userId}</td>
        <td>-</td>
        <td>-</td>
        <td>${stats.inTime || 'N/A'}</td>
        <td>${stats.outTime || 'N/A'}</td>
        <td>00:00:00</td>
        <td>0</td>
        <td>—</td>
      `;
      gapsTableBody.appendChild(row);
    }
  });
}


    /* ======================================================
     * Estatísticas Globais
     * ====================================================== */
    function updateStats(dataMap) {
  let sumWorkedHours = 0;
  let sumProdHours = 0;
  let totalPicked = 0;

  Object.values(dataMap).forEach(stats => {
    const hoursDecimal = timeToSeconds(stats.totalHours) / 3600;
    sumWorkedHours += hoursDecimal;
    sumProdHours += stats.qty / trackerTarget;
    totalPicked += stats.qty;
  });

  // NOVO: Total Gaps passa a somar a coluna "Total Gaps" da Home (stats.totalGaps em horas decimais)
  const sumGapsHours = Object.values(dataMap).reduce((acc, s) => acc + (s.totalGaps || 0), 0);

  document.getElementById('twhLabel').textContent = formatDecimalToTime(sumWorkedHours);
  document.getElementById('prodHoursLabel').textContent = formatDecimalToTime(sumProdHours);
  // Mostra na label "Total Gaps"
  document.getElementById('differenceLabel').textContent = formatDecimalToTime(sumGapsHours);

  const totalUsers = Object.keys(dataMap).length;
  document.getElementById('userCountLabel').textContent = totalUsers;

  // Mantive "T. User ID Lost" baseado na diferença TWH-ProdHours (como já era).
  // Se quiser que também use os Gaps, troca 'difference' por 'sumGapsHours' na linha abaixo.
 const lostDecimal = sumGapsHours / 7.5;
document.getElementById('userLostLabel').textContent = lostDecimal.toFixed(2);




  document.getElementById('totalPickedLabel').textContent =
  totalPicked.toLocaleString('en-US');


  const avgPickedPerHour = sumWorkedHours > 0 ? (totalPicked / sumWorkedHours) : 0;
  document.getElementById('avgPickedLabel').textContent = avgPickedPerHour.toFixed(0);

  let sumPerformance = 0;
const perfValues = []; // <- NOVO: coletar para mediana

Object.values(dataMap).forEach(stats => {
  const hours = timeToSeconds(stats.totalHours) / 3600;
  const perf = hours > 0 ? (stats.qty / (hours * trackerTarget)) * 100 : 0;
  sumPerformance += perf;
  perfValues.push(perf); // <- NOVO
});

const avgPerformance = totalUsers > 0 ? (sumPerformance / totalUsers) : 0;
document.getElementById('avgPerformanceLabel').textContent = avgPerformance.toFixed(2) + '%';

// NOVO: mediana
function median(arr){
  if (!arr || arr.length === 0) return 0;
  const s = [...arr].sort((a,b) => a - b);
  const mid = Math.floor(s.length / 2);
  return (s.length % 2 === 0) ? (s[mid - 1] + s[mid]) / 2 : s[mid];
}
const medianPerformance = median(perfValues);
const medianEl = document.getElementById('medianPerformanceLabel');
if (medianEl) medianEl.textContent = medianPerformance.toFixed(2) + '%';

}


    /* ======================================================
     * Filtros (Home)
     * ====================================================== */
// === Helper: devolve o mapa filtrado com base nos controles atuais da Home ===
function getFilteredMapFromUI(dataMap){
  const performanceFilter = document.getElementById('filterPerformance')?.value || "";
  const userIdFilter      = (document.getElementById('filterUserId')?.value || "").toLowerCase();
  const pickFilter        = document.getElementById('filterPick')?.value || "";
  const affFilterEl       = document.getElementById('filterAffiliation');
  const affFilter         = affFilterEl ? affFilterEl.value : "";

  const filtered = Object.entries(dataMap).filter(([userId, stats]) => {
    const matchesPerformance = !performanceFilter || stats.performance.includes(performanceFilter);
    const matchesUserId      = !userIdFilter || userId.toLowerCase().includes(userIdFilter);
    const pickVal            = stats.hasMulti ? 'Multi' : 'Single';
    const matchesPick        = !pickFilter || pickVal === pickFilter;

    const userAff            = getAffiliationFromUserId(userId);
    const matchesAff         = !affFilter || userAff === affFilter;

    return matchesPerformance && matchesUserId && matchesPick && matchesAff;
  });

  return Object.fromEntries(filtered);
}
function applyFilters(dataMap) {
  const filteredMap = getFilteredMapFromUI(dataMap);

  // Guarda o dataset filtrado para ser reaproveitado ao trocar de aba
  sessionStorage.setItem('onlinePickDataFiltered', JSON.stringify(filteredMap));
sessionStorage.setItem('onlinePickDataFiltered_ts', localStorage.getItem('onlinePickData_ts') || '');


  // Home
  updateTable(filteredMap);
  updateStats(filteredMap);

  // Dashboard (dinâmico com filtros)
  updateDashboard(filteredMap);
  renderDashboardCharts(filteredMap);
  renderDashboardTables(filteredMap);

    // Summary (Affiliation): se toggle ON, usa filtrado; se OFF, usa FULL (com TS)
const saved = localStorage.getItem('onlinePickData');
if (saved) {
  const fullTs = localStorage.getItem('onlinePickData_ts') || '';
  let src;

  if (affUseFiltered) {
    // usa o filtrado atual e atualiza o cache + timestamp
    src = filteredMap;
    sessionStorage.setItem('onlinePickDataFiltered', JSON.stringify(filteredMap));
    sessionStorage.setItem('onlinePickDataFiltered_ts', fullTs);
  } else {
    // usa o dataset completo
    src = JSON.parse(saved);
  }

  updateAffiliationSummary(src);
}

}

    function setFontSize(sheet, size) {
      Object.keys(sheet).forEach(function(cell) {
        if(cell.startsWith('!')) return;
        if(!sheet[cell].s) sheet[cell].s = {};
        if(!sheet[cell].s.font) sheet[cell].s.font = {};
        sheet[cell].s.font.sz = size;
      });
    }

    /* ======================================================
     * Eventos
     * ====================================================== */
    /* ======================================================
 * Eventos
 * ====================================================== */
/* ======================================================
 * Eventos
 * ====================================================== */
document.getElementById('csvFileInput').addEventListener('change', handleFileUpload);
document.getElementById('downloadReportBtnXLSX').addEventListener('click', downloadExcelReport);
document.getElementById('homeTabBtn').addEventListener('click', showHomeTab);
document.getElementById('gapsTabBtn').addEventListener('click', showGapsTab);
document.getElementById('dashboardTabBtn').addEventListener('click', showDashboardTab);
document.getElementById('affTabBtn').addEventListener('click', showAffiliationTab);


document.getElementById('filterPerformance').addEventListener('change', () => {
  const savedData = localStorage.getItem('onlinePickData');
  if (savedData) applyFilters(JSON.parse(savedData));
});
document.getElementById('filterUserId').addEventListener('input', () => {
  const savedData = localStorage.getItem('onlinePickData');
  if (savedData) applyFilters(JSON.parse(savedData));
});
document.getElementById('filterPick').addEventListener('change', () => {
  const savedData = localStorage.getItem('onlinePickData');
  if (savedData) applyFilters(JSON.parse(savedData));
});




    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        processCSV(e.target.result);
      };
      reader.readAsText(file);
    }

    // Popula filtros dinâmicos
    function populateFilterOptions(dataMap) {
      const perfSelect = document.getElementById('filterPerformance');
      perfSelect.innerHTML = '<option value="">All</option>';
      const perfSet = new Set(
        Object.values(dataMap).map(s => {
          if (s.performance.includes('Well Done'))   return 'Well Done';
          if (s.performance.includes('Almost There')) return 'Almost There';
          if (s.performance.includes('Poor'))         return 'Poor';
          return 'No Activity';
        })
      );
      perfSet.forEach(label => {
        const opt = document.createElement('option');
        opt.value = label; opt.textContent = label;
        perfSelect.appendChild(opt);
      });

      const pickSelect = document.getElementById('filterPick');
      pickSelect.innerHTML = '<option value="">All</option>';
      const pickSet = new Set(Object.values(dataMap).map(s => s.hasMulti ? 'Multi' : 'Single'));
      pickSet.forEach(label => {
        const opt = document.createElement('option');
        opt.value = label; opt.textContent = label;
        pickSelect.appendChild(opt);
      });
    }

    // ===== Mapa do CSV novo (0-based): A=0, ..., M=12, Q=16, T=19, U=20, AL=37
const COLS = {
  userId: 37,       // AL -> User ID
  qty: 16,          // Q  -> Update Qty
  location: 12,     // M  -> From Location / Location ID
  tranDate: 19,     // T  -> Transaction Date
  tranTime: 20,     // U  -> Transaction Time
  listId: 34,       // AI -> List ID  <<< NOVO
  dataStartRow: 2   // dados começam na linha 3 (1-based)
};

// === Limpeza de célula: remove BOM, trims e aspas de borda ===
function cleanCell(c) {
  return String(c ?? '')
    .replace(/^\uFEFF/, '')    // BOM
    .trim()                    // espaços nas bordas
    .replace(/^"(.*)"$/, '$1') // aspas duplas de borda
    .replace(/^'(.*)'$/, '$1');// aspas simples de borda
}

function processCSV(csvText) {
  try {
    // Prioriza TAB (TSV). Se não houver TAB e houver vírgula, usa ','
    let delimiter = '\t';
    if (!csvText.includes('\t') && csvText.includes(',')) delimiter = ',';

    // Linhas -> colunas, limpando cada célula e descartando linhas vazias
    const rows = csvText
      .split(/\r?\n/)
      .map(r => r.split(delimiter).map(cleanCell))
      .filter(r => r.some(c => (c || '').trim() !== ''));

    if (rows.length <= COLS.dataStartRow) {
      throw new Error('Arquivo sem linhas de dados após o cabeçalho.');
    }

    const dataMap = {};
    const validEvents = {};
    const allEvents = {};

    // Apenas a parte de dados
    const dataRows = rows.slice(COLS.dataStartRow);

    // Ordena por User ID e depois por horário (garante “ordem por User ID e Tempo”)
    const sortedRows = dataRows.slice().sort((a, b) => {
      const uA = (a[COLS.userId] || '').trim();
      const uB = (b[COLS.userId] || '').trim();
      if (uA !== uB) return uA.localeCompare(uB);
      const tA = normalizeTime((a[COLS.tranTime] || '').trim());
const tB = normalizeTime((b[COLS.tranTime] || '').trim());
return tA.localeCompare(tB);

    });

    // Agrega por user
sortedRows.forEach(row => {
  const userId          = (row[COLS.userId]   || '').trim();
  const qtyRaw          = (row[COLS.qty]      || '').trim();
  const location        = (row[COLS.location] || '').trim();
  const transactionDate = (row[COLS.tranDate] || '').trim();
  const listId          = (row[COLS.listId]   || '').trim();

  // Lê e normaliza o horário (corrige AM/PM)
  const transactionTimeCellValue = (row[COLS.tranTime] || '').trim();
  const transactionTimeNormalized = normalizeTime(transactionTimeCellValue);

  // Converte a quantidade em número
  const qty = Number(qtyRaw.replace(',', '.')) || 0;

  // Ignora linhas sem userId
  if (!userId) return;

  // Cria estrutura inicial do usuário se não existir
  if (!dataMap[userId]) {
    dataMap[userId] = {
      qty: 0,
      inTime: null,
      outTime: null,
      totalHours: 0,
      performance: '',
      performanceClass: '',
      totalGaps: 0,
      nGaps: 0,
      date: transactionDate || '',
      txnCount: 0,
      locationIn: '',
      locationOut: '',
      gapsList: [],
      hasMulti: false
    };
    validEvents[userId] = [];
    allEvents[userId] = [];
  }

  // Garante que cada user tenha uma data válida
  if (!dataMap[userId].date && transactionDate) {
    dataMap[userId].date = transactionDate;
  }

  // Soma quantidade e transações
  dataMap[userId].qty += qty;
  dataMap[userId].txnCount++;
  if (qty > 1) {
    dataMap[userId].hasMulti = true;
  }

  // =========================
  // Eventos (para cálculo de gaps)
  // =========================
  if (!dataMap[userId].__lastDate && transactionDate) {
    dataMap[userId].__lastDate = transactionDate;
  }

  const effectiveDate = transactionDate || dataMap[userId].__lastDate || '';

  if (effectiveDate) {
    dataMap[userId].__lastDate = effectiveDate;
  }

  const eventObject = {
    time: transactionTimeNormalized,
    location: location,
    listId: listId,
    date: effectiveDate,
    ts: normDate(effectiveDate) + ' ' + transactionTimeNormalized,
    fl: getFloor(location)
  };

  allEvents[userId].push(eventObject);
  validEvents[userId].push(eventObject);

  // =========================
  // In/Out time (comparação em formato 24h)
  // =========================
  const tNorm = transactionTimeNormalized;

  if (!dataMap[userId].inTime || tNorm < normalizeTime(dataMap[userId].inTime)) {
    dataMap[userId].inTime = tNorm;
    dataMap[userId].locationIn = location || '';
  }

  if (!dataMap[userId].outTime || tNorm > normalizeTime(dataMap[userId].outTime)) {
    dataMap[userId].outTime = tNorm;
    dataMap[userId].locationOut = location || '';
  }
});


    // Dedup por horário e ordena tempos por user
    function uniqByKey(arr, keyFn) {
  const seen = new Set();
  return arr.filter(obj => {
    const key = keyFn(obj);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

// helper p/ ordenar e comparar usando data+hora
// Normaliza datas (DD-MM-YYYY, DD/MM/YYYY ou YYYY-MM-DD) para YYYY-MM-DD
function normDate(s){
  if (!s) return '';
  const t = String(s).trim();
  const parts = t.includes('/') ? t.split('/') : t.split('-');
  let y, m, d;
  if (parts[0].length === 4) { // já YYYY-..-..
    [y, m, d] = parts;
  } else { // assume DD-..-YYYY
    [d, m, y] = parts;
  }
  return [
    String(y).padStart(4,'0'),
    String(m).padStart(2,'0'),
    String(d).padStart(2,'0')
  ].join('-');
}

// Chave consistente de ordenação/comparação: YYYY-MM-DD HH:MM:SS
function tsKey(o){
  const hhmmss = ensureTimeFormat(o.time || '00:00:00');
  return `${normDate(o.date || '')} ${hhmmss}`;
}

Object.keys(allEvents).forEach(userId => {
  allEvents[userId] = uniqByKey(
    allEvents[userId],
    o => `${o.date || ''}|${o.time}|${o.listId}|${o.location}`
  ).sort((a, b) => tsKey(a).localeCompare(tsKey(b)));
});

Object.keys(validEvents).forEach(userId => {
  validEvents[userId] = uniqByKey(
    validEvents[userId],
    o => `${o.date || ''}|${o.time}|${o.listId}|${o.location}`
  ).sort((a, b) => tsKey(a).localeCompare(tsKey(b)));

  // Define In/Out...
  const evs = validEvents[userId];
  if (evs.length){
    dataMap[userId].inTime      = evs[0].time || dataMap[userId].inTime;
    dataMap[userId].locationIn  = evs[0].location || dataMap[userId].locationIn;
    dataMap[userId].outTime     = evs[evs.length - 1].time || dataMap[userId].outTime;
    dataMap[userId].locationOut = evs[evs.length - 1].location || dataMap[userId].locationOut;
    if (!dataMap[userId].date && evs[0].date) dataMap[userId].date = evs[0].date;
  }
});




    // Cálculo de gaps com thresholds por piso (usa getFloor)
Object.keys(validEvents).forEach(userId => {
  const events = validEvents[userId];
  if (!events || events.length < 2) return;

  for (let i = 1; i < events.length; i++) {
    const prevObj = events[i - 1];
    const currObj = events[i];

    const diffSec   = calculateSecondsDifference(prevObj.time, currObj.time);
    const gapHours  = diffSec / 3600;

    // pisos
    const prevFloor = getFloor(prevObj.location);
    const currFloor = getFloor(currObj.location);
    const sameFloor = prevFloor && currFloor && (prevFloor === currFloor);

    // virada de List ID
    const listChanged = (String(prevObj.listId || '').trim() !== String(currObj.listId || '').trim());
    const fromList    = prevObj.listId || '';
    const toList      = currObj.listId || '';

    // threshold: 5 min no mesmo piso; 10 min entre pisos
    const thresholdMin   = sameFloor ? 5 : 10;
    const thresholdHours = thresholdMin / 60;

    if (gapHours >= thresholdHours) {
      dataMap[userId].totalGaps += gapHours;
      dataMap[userId].nGaps     += 1;
      dataMap[userId].gapsList.push({
        gapSec: diffSec,
        start: prevObj.time,
        end:   currObj.time,
        locationIn:  prevObj.location,
        locationOut: currObj.location,
        sameFloor,
        listChange: listChanged,
        fromList,
        toList
      });
    }
  }
});



    // Total Hours + Performance por user
    Object.keys(dataMap).forEach(userId => {
      const d = dataMap[userId];
      if (!d.inTime || !d.outTime) {
        delete dataMap[userId];
        return;
      }
      const totalHoursDecimal = calculateSecondsDifference(d.inTime, d.outTime) / 3600;
      d.totalHours = formatDecimalToTime(totalHoursDecimal);

      const performance = (totalHoursDecimal > 0 && d.qty > 0)
        ? (d.qty / (totalHoursDecimal * trackerTarget)) * 100
        : 0;

      if (totalHoursDecimal <= 0 || performance === 0) {
        d.performance      = "No Activity (0.00%)";
        d.performanceClass = "performance-no-activity";
      } else if (performance >= 100) {
        d.performance      = `Well Done (${performance.toFixed(2)}%)`;
        d.performanceClass = "performance-well-done";
      } else if (performance >= 60 && performance < 100) {
        d.performance      = `Almost There (${performance.toFixed(2)}%)`;
        d.performanceClass = "performance-almost-there";
      } else {
        d.performance      = `Poor (${performance.toFixed(2)}%)`;
        d.performanceClass = "performance-poor";
      }
    });

    // Persistência + refresh das views (mesmo fluxo de antes)
localStorage.setItem('onlinePickData', JSON.stringify(dataMap));
// — carimbo para detectar “dataset novo”
localStorage.setItem('onlinePickData_ts', String(Date.now()));

// — limpa qualquer cache filtrado antigo
sessionStorage.removeItem('onlinePickDataFiltered');
sessionStorage.removeItem('onlinePickDataFiltered_ts');

populateFilterOptions(dataMap);

// Rebuild imediato (sempre com dados frescos)
// Rebuild único; adia os gráficos para não “congelar”
rebuildUI(dataMap, { deferCharts: true });




  } catch (error) {
    console.error("Error processing CSV:", error);
    alert('Falha ao processar o CSV: ' + error.message);
  }
}
// Dashboard: Tabelas de destaque
function renderDashboardTables(dataMap) {
  const users = Object.entries(dataMap).map(([userId, s]) => {
    const hours = timeToSeconds(s.totalHours) / 3600;
    const perfNum = hours > 0 ? (s.qty / (hours * trackerTarget)) * 100 : 0;
    return { userId, perfNum, gapSec: s.totalGaps * 3600 };
  });

  const topPerformers = [...users].sort((a, b) => b.perfNum - a.perfNum).slice(0, 5);
  const topLow        = [...users].sort((a, b) => a.perfNum - b.perfNum).slice(0, 5);
  const topGaps       = [...users].sort((a, b) => b.gapSec - a.gapSec).slice(0, 5);

  function fillTable(tableId, rows, cols) {
    const tbody = document.getElementById(tableId).querySelector('tbody');
    tbody.innerHTML = '';
    rows.forEach(item => {
      const tr = document.createElement('tr');
      cols.forEach(col => {
        const td = document.createElement('td');
        td.textContent = item[col];
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
  }

  fillTable(
    'topPerformersTable',
    topPerformers.map(u => ({ userId: u.userId, Performance: u.perfNum.toFixed(2) + '%' })),
    ['userId', 'Performance']
  );

  fillTable(
    'topLowTable',
    topLow.map(u => ({ userId: u.userId, Performance: u.perfNum.toFixed(2) + '%' })),
    ['userId', 'Performance']
  );

  fillTable(
    'topGapsTable',
    topGaps.map(u => ({ userId: u.userId, 'Total Gap Time': formatDecimalToTime(u.gapSec / 3600) })),
    ['userId', 'Total Gap Time']
  );
}

    // Dashboard: Cards
    function updateDashboard(dataMap) {
      const totalUsers = Object.keys(dataMap).length;
      const totalPicks = Object.values(dataMap).reduce((sum, s) => sum + s.qty, 0);
      const sumWorkedHours = Object.values(dataMap).reduce((sum, s) => sum + (timeToSeconds(s.totalHours) / 3600), 0);
      const sumGapsSec = Object.values(dataMap).reduce((sum, s) => sum + s.totalGaps * 3600, 0);

      const avgPicksPerHour = sumWorkedHours > 0 ? (totalPicks / sumWorkedHours).toFixed(0) : "0.00";

      const sumPerf = Object.values(dataMap).reduce((sum, s) => {
        const hours = timeToSeconds(s.totalHours) / 3600;
        return sum + (hours > 0 ? (s.qty / (hours * trackerTarget)) * 100 : 0);
      }, 0);
      const avgPerf = totalUsers > 0 ? (sumPerf / totalUsers).toFixed(2) + "%" : "0.00%";

      const totalGapsTime = formatDecimalToTime(sumGapsSec / 3600);

      document.getElementById('dashboardUserCount').textContent = totalUsers;
      document.getElementById('dashboardTotalPicks').textContent = totalPicks;
      document.getElementById('dashboardAvgPicksPerHour').textContent = avgPicksPerHour;
      document.getElementById('dashboardAvgPerformance').textContent = avgPerf;
      document.getElementById('dashboardTotalGaps').textContent = totalGapsTime;
    }
function medianArray(arr){
  if (!arr || arr.length === 0) return 0;
  const s = [...arr].sort((a,b)=>a-b);
  const mid = Math.floor(s.length/2);
  return (s.length % 2 === 0) ? (s[mid-1] + s[mid]) / 2 : s[mid];
}

function computeAffMetrics(mapSubset){
  const entries = Object.entries(mapSubset);
  const users = entries.length;
  let sumPerf = 0, perfArr = [];
  let totalPicks = 0, sumWorkedHours = 0, sumGapsHours = 0;
  const buckets = { WD:0, AT:0, POOR:0, NA:0 };

  entries.forEach(([userId, s]) => {
    const hours = timeToSeconds(s.totalHours) / 3600;
    const perf = hours > 0 ? (s.qty / (hours * trackerTarget)) * 100 : 0;
    sumPerf += perf;
    perfArr.push(perf);
    totalPicks += s.qty || 0;
    sumWorkedHours += hours;
    sumGapsHours += (s.totalGaps || 0);

    if (s.performance.includes('Well Done')) buckets.WD++;
    else if (s.performance.includes('Almost There')) buckets.AT++;
    else if (s.performance.includes('Poor')) buckets.POOR++;
    else buckets.NA++;
  });

  const avgPerf = users ? (sumPerf/users) : 0;
  const medPerf = medianArray(perfArr);
  const avgPicksHr = sumWorkedHours > 0 ? (totalPicks / sumWorkedHours) : 0;

  return { users, avgPerf, medPerf, avgPicksHr, sumGapsHours, buckets };
}

function updateAffiliationSummary(dataMap){
  const coreEntries = Object.fromEntries(Object.entries(dataMap)
    .filter(([uid]) => getAffiliationFromUserId(uid)==='CORE'));
  const agyEntries  = Object.fromEntries(Object.entries(dataMap)
    .filter(([uid]) => getAffiliationFromUserId(uid)==='AGY'));

  const core = computeAffMetrics(coreEntries);
  const agy  = computeAffMetrics(agyEntries);

  // KPIs CORE
  document.getElementById('kpiCoreUsers').textContent = core.users;
  document.getElementById('kpiCoreAvgPerf').textContent = core.avgPerf.toFixed(2) + '%';
  document.getElementById('kpiCoreMedPerf').textContent = core.medPerf.toFixed(2) + '%';
  document.getElementById('kpiCoreAvgPicksHr').textContent = core.avgPicksHr.toFixed(2);
  document.getElementById('kpiCoreGaps').textContent = formatDecimalToTime(core.sumGapsHours);

  // KPIs AGY
  document.getElementById('kpiAgyUsers').textContent = agy.users;
  document.getElementById('kpiAgyAvgPerf').textContent = agy.avgPerf.toFixed(2) + '%';
  document.getElementById('kpiAgyMedPerf').textContent = agy.medPerf.toFixed(2) + '%';
  document.getElementById('kpiAgyAvgPicksHr').textContent = agy.avgPicksHr.toFixed(2);
  document.getElementById('kpiAgyGaps').textContent = formatDecimalToTime(agy.sumGapsHours);

  // Buckets
  document.getElementById('coreCountWD').textContent   = core.buckets.WD;
  document.getElementById('coreCountAT').textContent   = core.buckets.AT;
  document.getElementById('coreCountPoor').textContent = core.buckets.POOR;
  document.getElementById('coreCountNA').textContent   = core.buckets.NA;

  document.getElementById('agyCountWD').textContent   = agy.buckets.WD;
  document.getElementById('agyCountAT').textContent   = agy.buckets.AT;
  document.getElementById('agyCountPoor').textContent = agy.buckets.POOR;
  document.getElementById('agyCountNA').textContent   = agy.buckets.NA;

  // Charts
const perfCtx = document.getElementById('affAvgPerfChart').getContext('2d');
if (window.affAvgPerfChart && typeof window.affAvgPerfChart.destroy === 'function') {
  window.affAvgPerfChart.destroy();
}
window.affAvgPerfChart = new Chart(perfCtx, {
  type: 'bar',
  data: {
    labels: ['Median Performance (%)'],
    datasets: [
      { label: 'CORE', data: [core.medPerf], backgroundColor: '#28a745' }, // CORE primeiro (barra da esquerda)
      { label: 'AGY',  data: [agy.medPerf],  backgroundColor: '#ff8c00' }  // AGY depois (barra da direita)
    ]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    scales: { y: { beginAtZero: true } },
    plugins: {
      title: {
        display: true,
        text: 'Median Performance — AGY × CORE'
      },
      tooltip: {
        callbacks: {
          label: (ctx) => ` ${ctx.dataset.label}: ${Number(ctx.raw).toFixed(2)}%`
        }
      }
    }
  }
});

const bucketCtx = document.getElementById('affBucketChart').getContext('2d');
if (window.affBucketChart && typeof window.affBucketChart.destroy === 'function') {
  window.affBucketChart.destroy();
}
window.affBucketChart = new Chart(bucketCtx, {
  type: 'bar',
  data: {
    labels: ['CORE','AGY'], // CORE à esquerda
    datasets: [
      { label: 'Well Done',    data: [core.buckets.WD,  agy.buckets.WD],  backgroundColor: '#28a745' },
      { label: 'Almost There', data: [core.buckets.AT,  agy.buckets.AT],  backgroundColor: '#ff8c00' },
      { label: 'Poor',         data: [core.buckets.POOR,agy.buckets.POOR],backgroundColor: '#dc3545' },
      { label: 'No Activity',  data: [core.buckets.NA,  agy.buckets.NA],  backgroundColor: '#6c757d' }
    ]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } }
  }
});
}
    // Dashboard: Gráficos
    function renderDashboardCharts(dataMap) {
      const counts = { 'Well Done': 0, 'Almost There': 0, 'Poor': 0, 'No Activity': 0 };
      Object.values(dataMap).forEach(s => {
        if (s.performance.includes('Well Done'))        counts['Well Done']++;
        else if (s.performance.includes('Almost There')) counts['Almost There']++;
        else if (s.performance.includes('Poor'))         counts['Poor']++;
        else                                             counts['No Activity']++;
      });

      document.getElementById('countWellDone').textContent    = counts['Well Done'];
      document.getElementById('countAlmostThere').textContent = counts['Almost There'];
      document.getElementById('countPoor').textContent        = counts['Poor'];
      document.getElementById('countNoActivity').textContent  = counts['No Activity'];

      const labels = Object.keys(counts);
      const dataCounts = labels.map(l => counts[l]);

      const pieCtx = document.getElementById('performancePieChart').getContext('2d');
      if (window.performancePie) window.performancePie.destroy();
      window.performancePie = new Chart(pieCtx, {
        type: 'pie',
        data: {
          labels,
          datasets: [{
            data: dataCounts,
            backgroundColor: ['#28a745', '#ff8c00', '#dc3545', '#6c757d']
          }]
        },
        options: {
          plugins: {
            tooltip: {
              callbacks: {
                label: function(ctx) {
                  const total = ctx.dataset.data.reduce((sum, v) => sum + v, 0);
                  const pct   = total ? (ctx.raw / total * 100).toFixed(2) : '0.00';
                  return `${ctx.label}: ${pct}%`;
                }
              }
            },
            legend: {
              position: 'top',
              labels: {
                font: { size: 12 },
                boxWidth: 12,
                padding: 10,
                maxWidth: 1000,
                generateLabels: function(chart) {
                  const d = chart.data, total = d.datasets[0].data.reduce((s,v)=>s+v,0);
                  return d.labels.map((lab,i)=>({
                    text: `${lab} (${ total ? (d.datasets[0].data[i]/total*100).toFixed(2) : '0.00' }%)`,
                    fillStyle: d.datasets[0].backgroundColor[i],
                    hidden: false,
                    index: i
                  }));
                }
              }
            }
          }
        }
      });

      const barCtx = document.getElementById('performanceBarChart').getContext('2d');
      if (window.performanceBar) window.performanceBar.destroy();
      window.performanceBar = new Chart(barCtx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Users',
            data: dataCounts,
            backgroundColor: ['#28a745', '#ff8c00', '#dc3545', '#6c757d']
          }]
        },
        options: {
          scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } }
        }
      });
    }

    // On load (se já houver dados salvos)
    window.onload = function () {
  const savedData = localStorage.getItem('onlinePickData');
  if (!savedData) {
    setActiveTab('homeTabBtn');
    // ligar toggle mesmo sem dados (evita null)
    const affToggle = document.getElementById('affUseFilterToggle');
    if (affToggle) affToggle.checked = affUseFiltered;
    return;
  }

  const dataMap = JSON.parse(savedData);
  populateFilterOptions(dataMap);

  // 🔹 NOVO: resetar o cache filtrado para "sem filtro" (dataset completo)
  let ts = localStorage.getItem('onlinePickData_ts');
  if (!ts) {
    ts = String(Date.now());
    localStorage.setItem('onlinePickData_ts', ts);
  }
  sessionStorage.setItem('onlinePickDataFiltered', JSON.stringify(dataMap));
  sessionStorage.setItem('onlinePickDataFiltered_ts', ts);

  // reconstrói tudo com os dados completos
  rebuildUI(dataMap, { deferCharts: false });

  // NOVO: toggle do Summary
  const affToggle = document.getElementById('affUseFilterToggle');
  if (affToggle) {
    affToggle.checked = affUseFiltered;
    affToggle.addEventListener('change', () => {
      affUseFiltered = affToggle.checked;
      // se Summary estiver visível, refaz imediatamente
      const isSummaryVisible = document.getElementById('affiliationTabContent').style.display !== 'none';
      if (isSummaryVisible) {
        const src = getSummarySourceMap();
        if (src) updateAffiliationSummary(src);
      }
    });
  }

  setActiveTab('homeTabBtn');
};


    function downloadExcelReport() {
      const savedData = localStorage.getItem('onlinePickData');
      if (!savedData) { alert('No data to download. Please upload a file first.'); return; }
      
      const dataMap = JSON.parse(savedData);
      const header = ['Date', 'User ID', 'Qty', 'In Time', 'Out Time', 'Total Hours', 'Prod. Hours', 'Performance', 'Total Gaps', 'N. Gaps', 'Qty. Tnx', 'Gap vs Txn%', 'Avg. P. Hours', 'Pick'];
      const allData = [header.slice()];
      const wellDoneData = [header.slice()];
      const almostThereData = [header.slice()];
      const poorData = [header.slice()];

      Object.entries(dataMap).forEach(([userId, stats]) => {
        const { qty, inTime, outTime, totalHours, performance, totalGaps, nGaps, date, txnCount } = stats;
        const prodHours = formatDecimalToTime(qty / trackerTarget);
        const gapTxnPercent = txnCount ? ((nGaps / txnCount) * 100).toFixed(2) + "%" : "0.00%";
        const totalHoursDecimal = timeToSeconds(totalHours) / 3600;
        const avgPHours = totalHoursDecimal > 0 ? (qty / totalHoursDecimal).toFixed(2) : "0";
        const pick = stats.hasMulti ? 'Multi' : 'Single';
        
        const row = [
          date, userId, qty, inTime, outTime, totalHours, prodHours, performance,
          formatDecimalToTime(totalGaps), nGaps, txnCount, gapTxnPercent, avgPHours, pick
        ];
        allData.push(row);
        if (performance.includes('Well Done'))      wellDoneData.push(row);
        else if (performance.includes('Almost There')) almostThereData.push(row);
        else if (performance.includes('Poor'))         poorData.push(row);
      });
      
      const gapsHeader = [
  'Date','User ID','Location IN','Location OUT','In Time','Out Time',
  'Gap Time','Gap #','Same Floor?','List Change','List From','List To'
];
const gapsData = [gapsHeader.slice()];


      Object.entries(dataMap).forEach(([userId, stats]) => {
  if (stats.nGaps > 0 && stats.gapsList && stats.gapsList.length > 0) {
    stats.gapsList.forEach((gapObj, index) => {
      const gapTimeFormatted = formatDecimalToTime(gapObj.gapSec / 3600);
      const sameFloorFlag = gapObj.sameFloor ? 'Yes' : 'No';

      // >>> NOVO: se virou o List ID, adiciona asteriscos no texto de Location IN/OUT
      const locIn  = gapObj.listChange ? `*${gapObj.locationIn || ''}*`  : (gapObj.locationIn  || '');
      const locOut = gapObj.listChange ? `*${gapObj.locationOut || ''}*` : (gapObj.locationOut || '');
      // <<< FIM NOVO

      const row = [
  stats.date, userId,
  // mantém os asteriscos quando houver virada
  gapObj.listChange ? `*${gapObj.locationIn || ''}*`  : (gapObj.locationIn  || ''),
  gapObj.listChange ? `*${gapObj.locationOut || ''}*` : (gapObj.locationOut || ''),
  gapObj.start, gapObj.end,
  gapTimeFormatted, index + 1, sameFloorFlag,
  // NOVO: colunas extras para filtrar no Excel
  gapObj.listChange ? 'Yes' : 'No',
  gapObj.fromList || '', gapObj.toList || ''
];
gapsData.push(row);

    });
  }
});


      const workbook = XLSX.utils.book_new();
const wsAll = XLSX.utils.aoa_to_sheet(allData);
const wsWellDone = XLSX.utils.aoa_to_sheet(wellDoneData);
const wsAlmostThere = XLSX.utils.aoa_to_sheet(almostThereData);
const wsPoor = XLSX.utils.aoa_to_sheet(poorData);
const wsGaps = XLSX.utils.aoa_to_sheet(gapsData);

// Helper para ligar AutoFilter em qualquer sheet
function enableAutofilter(ws) {
  if (!ws['!ref']) return;
  const r = XLSX.utils.decode_range(ws['!ref']);
  ws['!autofilter'] = {
    ref: XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: r.e.r, c: r.e.c } })
  };
}

// Liga o AutoFilter em todas as abas
enableAutofilter(wsAll);
enableAutofilter(wsWellDone);
enableAutofilter(wsAlmostThere);
enableAutofilter(wsPoor);
enableAutofilter(wsGaps);

// (se quiser, aqui também dá pra definir larguras de coluna, ex.: wsGaps['!cols'] = [...])

// Ativa o filtro no intervalo todo
wsGaps['!autofilter'] = {
  ref: XLSX.utils.encode_range({
    s: { r: 0, c: 0 },
    e: { r: gapsData.length - 1, c: gapsHeader.length - 1 }
  })
};


setFontSize(wsAll, 11); setFontSize(wsWellDone, 11);
setFontSize(wsAlmostThere, 11); setFontSize(wsPoor, 11);
setFontSize(wsGaps, 11);

// === NOVO: forçar tipos e formatos no Excel ===
function toExcelSerialFromHMS(str) {
  if (!str) return 0;
  const s = timeToSeconds(ensureTimeFormat(String(str).trim()));
  return s / 86400; // fração de dia
}
function castAllSheets(ws) {
  if (!ws['!ref']) return;
  const r = XLSX.utils.decode_range(ws['!ref']);

  // Colunas (0-based) em "All Data" e similares:
  // 0 Date | 1 User | 2 Qty | 3 In | 4 Out | 5 Total H | 6 Prod H | 7 Performance
  // 8 Total Gaps | 9 N. Gaps | 10 Qty. Tnx | 11 Gap vs Txn% | 12 Avg. P. Hours | 13 Pick
  const C = {QTY:2, IN:3, OUT:4, TOT_H:5, PROD_H:6, GAPS:8, N_G:9, TXN:10, GAP_PCT:11, AVG_PH:12};

  for (let row = r.s.r + 1; row <= r.e.r; row++) { // pula cabeçalho
    // Qty (número)
    let addr = XLSX.utils.encode_cell({r: row, c: C.QTY});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = Number(ws[addr].v) || 0; ws[addr].z = '0'; }

    // In/Out time (hora do dia)
    [C.IN, C.OUT].forEach(c => {
      const a = XLSX.utils.encode_cell({r: row, c});
      if (ws[a]) { ws[a].t = 'n'; ws[a].v = toExcelSerialFromHMS(ws[a].v); ws[a].z = 'hh:mm:ss'; }
    });

    // Total Hours (duração potencial >24h)
    addr = XLSX.utils.encode_cell({r: row, c: C.TOT_H});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = toExcelSerialFromHMS(ws[addr].v); ws[addr].z = '[h]:mm:ss'; }

    // Prod. Hours = qty/target (em horas) -> fração de dia
    const aQty = XLSX.utils.encode_cell({r: row, c: C.QTY});
    const qtyVal = (ws[aQty] && typeof ws[aQty].v === 'number') ? ws[aQty].v : Number(ws[aQty]?.v) || 0;
    const prodSerial = (qtyVal / trackerTarget) / 24;
    addr = XLSX.utils.encode_cell({r: row, c: C.PROD_H});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = prodSerial; ws[addr].z = '[h]:mm:ss'; }

    // Total Gaps (duração >24h possível)
    addr = XLSX.utils.encode_cell({r: row, c: C.GAPS});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = toExcelSerialFromHMS(ws[addr].v); ws[addr].z = '[h]:mm:ss'; }

    // N. Gaps e Qty. Tnx (número)
    [C.N_G, C.TXN].forEach(c => {
      const a = XLSX.utils.encode_cell({r: row, c});
      if (ws[a]) { ws[a].t = 'n'; ws[a].v = Number(ws[a].v) || 0; ws[a].z = '0'; }
    });

    // Gap vs Txn% = nGaps / txnCount
    const aNG = XLSX.utils.encode_cell({r: row, c: C.N_G});
    const aTX = XLSX.utils.encode_cell({r: row, c: C.TXN});
    const nG = Number(ws[aNG]?.v) || 0, tx = Number(ws[aTX]?.v) || 0;
    const pct = tx > 0 ? (nG / tx) : 0;
    addr = XLSX.utils.encode_cell({r: row, c: C.GAP_PCT});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = pct; ws[addr].z = '0.00%'; }

    // Avg. P. Hours = Qty / (TotalHours em horas)
    const aTH = XLSX.utils.encode_cell({r: row, c: C.TOT_H});
    const totHours = (ws[aTH]?.v || 0) * 24; // serial -> horas
    const avgPH = totHours > 0 ? (qtyVal / totHours) : 0;
    addr = XLSX.utils.encode_cell({r: row, c: C.AVG_PH});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = avgPH; ws[addr].z = '0.00'; }
  }
}

// Gaps Breakdown: 0 Date | 1 User | 2 Loc IN | 3 Loc OUT | 4 In | 5 Out | 6 Gap Time | 7 Gap # | 8 Same Floor?
function castGapsSheet(ws) {
  if (!ws['!ref']) return;
  const r = XLSX.utils.decode_range(ws['!ref']);
  for (let row = r.s.r + 1; row <= r.e.r; row++) {
    // In/Out time
    [4,5].forEach(c => {
      const a = XLSX.utils.encode_cell({r: row, c});
      if (ws[a]) { ws[a].t = 'n'; ws[a].v = toExcelSerialFromHMS(ws[a].v); ws[a].z = 'hh:mm:ss'; }
    });
    // Gap Time (duração)
    let addr = XLSX.utils.encode_cell({r: row, c: 6});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = toExcelSerialFromHMS(ws[addr].v); ws[addr].z = '[h]:mm:ss'; }
    // Gap #
    addr = XLSX.utils.encode_cell({r: row, c: 7});
    if (ws[addr]) { ws[addr].t = 'n'; ws[addr].v = Number(ws[addr].v) || 0; ws[addr].z = '0'; }
  }
}

// Aplicar nos 4 sheets principais + Gaps
[wsAll, wsWellDone, wsAlmostThere, wsPoor].forEach(castAllSheets);
castGapsSheet(wsGaps);

// ============================
XLSX.utils.book_append_sheet(workbook, wsAll, "All Data");
XLSX.utils.book_append_sheet(workbook, wsWellDone, "Well Done");
XLSX.utils.book_append_sheet(workbook, wsAlmostThere, "Almost There");
XLSX.utils.book_append_sheet(workbook, wsPoor, "Poor");
XLSX.utils.book_append_sheet(workbook, wsGaps, "Gaps Breakdown");

XLSX.writeFile(workbook, "OnLine_Picking_Report.xlsx");

    }
  </script>

  <!-- Script para Filtro Dinâmico na Aba Gaps (NOVA VERSÃO) -->
<script>
(function () {
  // Lê o mesmo dataset filtrado que a Home guarda no sessionStorage.
  // Se não existir cache (primeiro uso), recalcula usando os controles da Home.
  function currentFilteredMap() {
    const fullSaved = localStorage.getItem('onlinePickData');
    if (!fullSaved) return {};

    const fullTs   = localStorage.getItem('onlinePickData_ts') || '';
    const cached   = sessionStorage.getItem('onlinePickDataFiltered');
    const cachedTs = sessionStorage.getItem('onlinePickDataFiltered_ts') || '';

    if (cached && cachedTs === fullTs) {
      try { return JSON.parse(cached); } catch (_) {}
    }
    // fallback: calcula agora com os filtros atuais da Home
    return getFilteredMapFromUI(JSON.parse(fullSaved));
  }

  function refreshGaps() {
    updateGapsTable(currentFilteredMap());
  }

  // Ao entrar na aba Gaps, usa exatamente o mesmo filtro da Home
  document.getElementById('gapsTabBtn').addEventListener('click', refreshGaps);

  // Quando mudares filtros na Home:
  // - os listeners principais já chamam applyFilters (que atualiza o cache filtrado)
  // - aqui apenas atualizamos a Gaps SE ela estiver visível
  const isGapsVisible = () => document.getElementById('gapsTabContent').style.display !== 'none';

  ['filterUserId','filterPerformance','filterPick','filterAffiliation'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;

    const evt = (id === 'filterUserId') ? 'input' : 'change';
    el.addEventListener(evt, () => {
      // garante que o cache filtrado está atualizado:
      if (id === 'filterAffiliation') {
        const saved = localStorage.getItem('onlinePickData');
        if (saved) applyFilters(JSON.parse(saved)); // Home + cache
      }
      // se a aba Gaps estiver aberta, refletir imediatamente
      if (isGapsVisible()) refreshGaps();
    });
  });
})();
</script>


  <!-- ======= Proteção mínima (insere AQUI, antes de </body>) ======= -->
  <style>
  /* bloqueia seleção globalmente */
  * { -webkit-user-select: none; -ms-user-select: none; user-select: none; }

  /* libera em inputs/selects */
  input, textarea, select {
    -webkit-user-select: text; -ms-user-select: text; user-select: text;
  }

  /* libera dentro das abas (Home, Gaps, etc.) */
  .allow-copy, .allow-copy * {
    -webkit-user-select: text !important;
    -ms-user-select: text !important;
    user-select: text !important;
  }
</style>


  <script>
  // Bloqueios leves: contexto, seleção, arrasto
  document.addEventListener('contextmenu', e => {
  if (e.target.closest('.allow-copy')) return; // permite nas áreas liberadas
  e.preventDefault();
}, { capture: true });

document.addEventListener('selectstart', e => {
  if (e.target.closest('.allow-copy')) return; // permite seleção nas abas liberadas
  if (/INPUT|TEXTAREA|SELECT/.test(e.target.tagName)) return;
  e.preventDefault();
}, { capture: true });

  document.addEventListener('dragstart', e => e.preventDefault(), { capture: true });

  // Bloqueio de atalhos comuns (versão segura)
document.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  const ctrl = e.ctrlKey || e.metaKey;
  const shift = e.shiftKey;

  // verifica se está numa área permitida
  const sel = window.getSelection && window.getSelection();
  const selNode = sel && sel.anchorNode
    ? (sel.anchorNode.nodeType === 1 ? sel.anchorNode : sel.anchorNode.parentElement)
    : null;
  const inAllow = (document.activeElement && document.activeElement.closest('.allow-copy')) ||
                  (selNode && selNode.closest && selNode.closest('.allow-copy'));

  // 1) SEMPRE bloquear ver código / DevTools, em qualquer lugar
  if ((ctrl && k === 'u') || e.key === 'F12' || (ctrl && shift && ['i','j','c'].includes(k))) {
    e.preventDefault();
    e.stopPropagation();
    return;
  }

  // 2) Fora das áreas copiáveis, bloquear copiar / selecionar / imprimir / salvar
  if (!inAllow && ctrl && ['c','a','p','s'].includes(k)) {
    e.preventDefault();
    e.stopPropagation();
    return;
  }

  // 3) Dentro das abas copiáveis, Ctrl+C/A/S/P funcionam normalmente
}, { capture: true });


</script>

  <!-- ======= fim proteção mínima ======= -->

</body>
</html>



